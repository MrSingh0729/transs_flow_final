# Integrating Lark and Feishu Access Token Handling in Your Django PWA

Based on your code, I can see you've already set up the foundation for Lark/Feishu integration. Here's how to complete the implementation for handling both platforms' access tokens and URLs:

## 1. Update Your Django View to Handle Access Tokens

First, modify your `view.py` to handle the access token:

```python
# Add this import at the top
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST

# Add this view to handle receiving the access token
@csrf_exempt
@require_POST
def receive_platform_token(request):
    try:
        data = json.loads(request.body)
        open_id = data.get('open_id')
        app_access_token = data.get('app_access_token')
        tenant_key = data.get('tenant_key')
        platform = data.get('platform')
        
        # Store the token in the user's session
        request.session[f'{platform}_access_token'] = app_access_token
        request.session[f'{platform}_open_id'] = open_id
        request.session[f'{platform}_tenant_key'] = tenant_key
        
        return JsonResponse({'status': 'success'})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=400)

# Update your form_valid method to handle iframe URLs with tokens
def form_valid(self, form):
    scanned_url = self.request.POST.get("scanned_result")
    if scanned_url:
        form.instance.scanned_barcode_text = scanned_url
        messages.success(self.request, "✅ QR/Barcode scanned and saved successfully.")
    else:
        messages.warning(self.request, "⚠️ No QR/Barcode scanned.")
        
    # Get the platform and access token
    platform = 'lark' if 'window.lark' in str(self.request.META.get('HTTP_USER_AGENT', '')) else 'feishu'
    access_token = self.request.session.get(f'{platform}_access_token')
    
    # Add data to context for frontend to save to IndexedDB
    context = {
        'offline_data': {
            'type': 'operator_qualification',
            'id': str(form.instance.id),
            'data': {
                'date': str(form.instance.date),
                'shift': form.instance.shift,
                'emp_id': form.instance.emp_id,
                'name': form.instance.name,
                'section': form.instance.section,
                'line': form.instance.line,
                'group': form.instance.group,
                'model': form.instance.model,
                'color': form.instance.color,
            }
        },
        'scanned_url': scanned_url,
        'platform': platform,
        'access_token': access_token
    }
    
    return render(self.request, 'ipqc/operator_qualification_success.html', context)
```

## 2. Add URL Routing

In your `urls.py`, add the new endpoint:

```python
from django.urls import path
from .views import OperatorQualificationCheckCreateView, receive_platform_token

urlpatterns = [
    # ... your existing URLs
    path('receive-platform-token/', receive_platform_token, name='receive_platform_token'),
]
```

## 3. Update Your Base Template

Modify the JavaScript in `base.html` to properly handle both platforms:

```javascript
// Replace the existing platform detection code with this:
let platform = null;
let sdk = null;

// Detect environment and initialize the appropriate SDK
if (window.lark) {
    platform = "lark";
    sdk = lark;
} else if (window.feishu) {
    platform = "feishu";
    sdk = feishu;
}

function sendTokenToBackend(context) {
    const open_id = context.user.open_id;
    const app_access_token = context.app_access_token;
    const tenant_key = context.tenant.key;

    fetch('/receive-platform-token/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': '{{ csrf_token }}'
        },
        body: JSON.stringify({
            open_id,
            app_access_token,
            tenant_key,
            platform
        })
    })
    .then(res => res.json())
    .then(data => {
        console.log('Backend login response:', data);
        // Store token in localStorage for iframe use
        localStorage.setItem(`${platform}_access_token`, app_access_token);
    })
    .catch(err => console.error('Error sending token:', err));
}

// Initialize SDK based on platform
if (platform && sdk) {
    sdk.ready(() => {
        sdk.getContext().then(sendTokenToBackend)
          .catch(err => console.error(`${platform} getContext error:`, err));
    });
} else {
    console.log("Not in Lark/Feishu mini app environment.");
}

// Add function to get access token
function getAccessToken() {
    return localStorage.getItem(`${platform}_access_token`) || null;
}

// Add function to create authenticated URLs
function createAuthenticatedUrl(baseUrl) {
    const token = getAccessToken();
    if (!token) return baseUrl;
    
    // Add token to URL based on platform
    if (platform === 'lark') {
        const separator = baseUrl.includes('?') ? '&' : '?';
        return `${baseUrl}${separator}access_token=${token}`;
    } else if (platform === 'feishu') {
        const separator = baseUrl.includes('?') ? '&' : '?';
        return `${baseUrl}${separator}app_access_token=${token}`;
    }
    
    return baseUrl;
}

// Expose functions globally
window.getPlatform = () => platform;
window.getAccessToken = getAccessToken;
window.createAuthenticatedUrl = createAuthenticatedUrl;
```

## 4. Update Your Form Template

Modify the `operator_qualification_form.html` to properly handle both platforms:

```javascript
// Update the showFeishuLink function to handle both platforms
function showPlatformLink(url) {
    const preview = document.getElementById('feishu-preview');
    const iframeContainer = document.getElementById('feishu-iframe-container');
    const iframe = document.getElementById('feishu-iframe');
    
    // Create authenticated URL
    const authenticatedUrl = createAuthenticatedUrl(url);
    
    preview.innerHTML = `
        <div class="alert alert-success">
            <i class="fas fa-check-circle"></i> ${platform.charAt(0).toUpperCase() + platform.slice(1)} link scanned successfully!
            <br>
            <a href="${authenticatedUrl}" target="_blank" class="btn btn-sm btn-primary mt-2">
                <i class="fas fa-external-link-alt"></i> Open Record
            </a>
        </div>
    `;
    
    // Show iframe preview
    iframeContainer.style.display = 'block';
    iframe.src = authenticatedUrl;
    
    // Store the URL in the form field
    const barcodeField = document.querySelector('[name="scanned_barcode_text"]');
    barcodeField.value = authenticatedUrl;
}

// Update the QR scanner success callback
html5QrCode.start(
    cameraConfig,
    { fps: 10, qrbox: 250 },
    decoded => {
        // Update single form field
        barcodeField.value = decoded;
        
        // Capture snapshot before stopping
        captureSnapshot();
        
        stopQRScanner();
        showPlatformLink(decoded);
        isScanSuccessful = true;
    },
    error => {
        // Ignore scan errors
    }
);
```

## 5. Add CSRF Protection for Token Endpoint

Create a context processor to ensure CSRF token is available in all templates:

```python
# In context_processors.py
def csrf_token(request):
    return {'csrf_token': str(request.META.get('CSRF_COOKIE', ''))}
```

And add it to your settings:

```python
# In settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'your_app.context_processors.csrf_token',
            ],
        },
    },
]
```

## 6. Create a Utility Function for URL Handling

Create a utility module to help with URL handling:

```python
# In utils.py
import json
from urllib.parse import urlparse, parse_qs, urlunparse, urlencode

def add_token_to_url(url, platform, access_token):
    """
    Add platform-specific token to URL
    """
    if not access_token:
        return url
    
    parsed_url = list(urlparse(url))
    
    if platform == 'lark':
        # Add access_token as query parameter
        query_params = parse_qs(parsed_url[4])
        query_params['access_token'] = [access_token]
        parsed_url[4] = urlencode(query_params, doseq=True)
    elif platform == 'feishu':
        # Add app_access_token as query parameter
        query_params = parse_qs(parsed_url[4])
        query_params['app_access_token'] = [access_token]
        parsed_url[4] = urlencode(query_params, doseq=True)
    
    return urlunparse(parsed_url)
```

## Summary of Changes:

1. **Django View**: Added endpoint to receive and store platform tokens
2. **URL Routing**: Added route for the token endpoint
3. **Base Template**: Enhanced platform detection and token handling
4. **Form Template**: Updated QR scanner to use authenticated URLs
5. **Security**: Added CSRF protection for the token endpoint
6. **Utilities**: Created helper function for URL token handling

This implementation will:
- Detect whether your app is running in Lark or Feishu
- Get the access token from the platform
- Store the token in both session and localStorage
- Use the token to create authenticated URLs for iframes
- Handle both platforms' URL parameter formats

The solution is backward compatible and will work whether the app is embedded in Lark/Feishu or accessed as a standalone PWA.